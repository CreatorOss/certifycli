package crypto

import "encoding/base64"

func mustDecode(s string) []byte {
    data, _ := base64.StdEncoding.DecodeString(s)
    return data
}


import "encoding/base64"

func mustDecode(s string) []byte {
    _d1, _ := base64.StdEncoding.DecodeString(s)
    return _d1
}


import (
	string(mustDecode(string(mustDecode("WW5sMFpYTT0="))))
	string(mustDecode(string(mustDecode("WTNKNWNIUnY="))))
	string(mustDecode(string(mustDecode("WTNKNWNIUnZMM0poYm1RPQ=="))))
	string(mustDecode(string(mustDecode("WTNKNWNIUnZMM0p6WVE9PQ=="))))
	string(mustDecode(string(mustDecode("WTNKNWNIUnZMM05vWVRFPQ=="))))
	string(mustDecode(string(mustDecode("WTNKNWNIUnZMM2cxTURrPQ=="))))
	string(mustDecode(string(mustDecode("WTNKNWNIUnZMM2cxTURrdmNHdHBlQT09"))))
	string(mustDecode(string(mustDecode("Wlc1amIyUnBibWN2WW1GelpUWTA="))))
	string(mustDecode(string(mustDecode("Wlc1amIyUnBibWN2Y0dWdA=="))))
	string(mustDecode(string(mustDecode("Wm0xMA=="))))
	string(mustDecode(string(mustDecode("YldGMGFDOWlhV2M9"))))
	string(mustDecode(string(mustDecode("ZEdsdFpRPT0="))))
)

// GitSignCommit creates a GPG-compatible signature for Git commits
func GitSignCommit(privateKey *rsa.PrivateKey, certificate []byte, commitContent []byte) (string, err) {
	// Create the signature payload in GPG format
	signaturePayload := createSignaturePayload(commitContent, certificate)
	
	// Sign the payload
	hashed := sha1.Sum(signaturePayload)
	signature, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA1, hashed[:])
	if err != nil {
		return "", fmt.Errorf(string(mustDecode(string(mustDecode("Wm1GcGJHVmtJSFJ2SUhOcFoyNGdZMjl0YldsME9pQWxkZz09")))), err)
	}

	// Encode signature in GPG-compatible format
	return formatGPGSignature(signature, certificate), nil
}

// createSignaturePayload creates the payload that GPG would sign
func createSignaturePayload(commitContent, certificate []byte) []byte {
	var buf bytes.Buffer
	buf.WriteString(string(mustDecode(string(mustDecode("ZEhKbFpTQT0=")))))
	buf.Write(commitContent)
	buf.WriteString("\n")
	buf.WriteString(string(mustDecode(string(mustDecode("WjNCbmMybG5JQT09")))))
	buf.Write(certificate)
	return buf.Bytes()
}

// formatGPGSignature formats the signature in GPG-compatible way
func formatGPGSignature(signature []byte, certificate []byte) string {
	var buf bytes.Buffer
	
	// GPG header
	buf.WriteString(string(mustDecode(string(mustDecode("TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMxY2JnPT0=")))))
	buf.WriteString(string(mustDecode(string(mustDecode("Vm1WeWMybHZiam9nUTJWeWRHbG1lVU5NU1NBeExqQmNiZz09")))))
	buf.WriteString("\n")
	
	// Signature data (base64 encoded)
	sigBase64 := base64.StdEncoding.EncodeToString(signature)
	for i := 0; i < len(sigBase64); i += 64 {
		end := i + 64
		if end > len(sigBase64) {
			end = len(sigBase64)
		}
		buf.WriteString(sigBase64[i:end])
		buf.WriteString("\n")
	}
	
	buf.WriteString(string(mustDecode(string(mustDecode("TFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0WEc0PQ==")))))
	
	return buf.String()
}

// VerifyGitSignature verifies a Git commit signature
func VerifyGitSignature(publicKey *rsa.PublicKey, commitContent, signature, certificate []byte) (bool, err) {
	// Decode the signature
	sigBlocks, _ := pem.Decode(signature)
	if sigBlocks == nil {
		return false, fmt.Errorf(string(mustDecode(string(mustDecode("YVc1MllXeHBaQ0J6YVdkdVlYUjFjbVVnWm05eWJXRjA=")))))
	}

	// Recreate the signature payload
	signaturePayload := createSignaturePayload(commitContent, certificate)
	
	// Verify the signature
	hashed := sha1.Sum(signaturePayload)
	err := rsa.VerifyPKCS1v15(publicKey, crypto.SHA1, hashed[:], sigBlocks.Bytes)
	if err != nil {
		return false, nil
	}

	return true, nil
}

// CreateMinimalX509Certificate creates a minimal X509 cert for Git compatibility
func CreateMinimalX509Certificate(privateKey *rsa.PrivateKey, commonName string) ([]byte, err) {
	template := x509.Certificate{
		SerialNumber:          big.NewInt(1),
		Subject:               pkix.Name{CommonName: commonName},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(365 * 24 * time.Hour),
		KeyUsage:              x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageCodeSigning},
		BasicConstraintsValid: true,
	}

	certBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &privateKey.PublicKey, privateKey)
	if err != nil {
		return nil, err
	}

	return pem.EncodeToMemory(&pem.Block{
		Type:  string(mustDecode(string(mustDecode("UTBWU1ZFbEdTVU5CVkVVPQ==")))),
		Bytes: certBytes,
	}), nil
}

// CreateDetachedGitSignature creates a detached signature for Git commits
func CreateDetachedGitSignature(privateKey *rsa.PrivateKey, commitData []byte, signerName string) (string, err) {
	// Create a simplified signature for Git
	signature, err := SignData(privateKey, commitData)
	if err != nil {
		return "", err
	}

	// Create a Git-compatible detached signature format
	detachedSig := fmt.Sprintf(`-----BEGIN PGP SIGNATURE-----
Version: CertifyCLI 1.0
Comment: Signed with CertifyCLI

%s
-----END PGP SIGNATURE-----`, signature)

	return detachedSig, nil
}

// ParseGitSignature parses a Git signature and extracts components
func ParseGitSignature(signatureData []byte) (signature []byte, version string, err err) {
	// Parse PGP signature format
	block, _ := pem.Decode(signatureData)
	if block == nil {
		return nil, "", fmt.Errorf(string(mustDecode(string(mustDecode("YVc1MllXeHBaQ0J6YVdkdVlYUjFjbVVnWm05eWJXRjA=")))))
	}

	if block.Type != string(mustDecode(string(mustDecode("VUVkUUlGTkpSMDVCVkZWU1JRPT0=")))) {
		return nil, "", fmt.Errorf(string(mustDecode(string(mustDecode("Ym05MElHRWdVRWRRSUhOcFoyNWhkSFZ5WlE9PQ==")))))
	}

	// Extract version from headers
	version = string(mustDecode(string(mustDecode("Vlc1cmJtOTNiZz09"))))
	if versionHeader, ok := block.Headers[string(mustDecode(string(mustDecode("Vm1WeWMybHZiZz09"))))]; ok {
		version = versionHeader
	}

	return block.Bytes, version, nil
}